package com.visor.school.attendance.model;

import jakarta.persistence.*;
import java.time.Instant;
import java.time.LocalDate;
import java.util.UUID;

/**
 * Attendance session for delegation to class leaders
 * Each session represents attendance collection for a specific date and class
 */
@Entity
@Table(name = "attendance_sessions", indexes = {
    @Index(name = "idx_sessions_class_date", columnList = "class_id,date", unique = true),
    @Index(name = "idx_sessions_delegated_to", columnList = "delegated_to"),
    @Index(name = "idx_sessions_status", columnList = "status"),
    @Index(name = "idx_sessions_created_by", columnList = "created_by")
})
public class AttendanceSession {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "class_id", nullable = false)
    private UUID classId;

    @Column(name = "date", nullable = false)
    private LocalDate date;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private AttendanceSessionStatus status;

    @Column(name = "delegated_to")
    private UUID delegatedTo; // Student ID (class leader) - nullable initially, set during delegation

    @Column(name = "created_by", nullable = false)
    private UUID createdBy; // Teacher ID

    @Column(name = "approved_by")
    private UUID approvedBy; // Teacher ID

    @Column(name = "rejected_by")
    private UUID rejectedBy; // Teacher ID

    @Column(name = "rejection_reason", columnDefinition = "TEXT")
    private String rejectionReason;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "collected_at")
    private Instant collectedAt;

    @Column(name = "approved_at")
    private Instant approvedAt;

    @Column(name = "rejected_at")
    private Instant rejectedAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    // Default constructor for JPA
    protected AttendanceSession() {
        // ID is generated by JPA
        this.status = AttendanceSessionStatus.PENDING;
        this.createdAt = Instant.now();
        this.updatedAt = Instant.now();
    }

    // Constructor with required fields
    public AttendanceSession(UUID classId, LocalDate date, UUID createdBy) {
        this();
        this.classId = classId;
        this.date = date;
        this.createdBy = createdBy;
        validate();
    }

    private void validate() {
        if (date.isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("Attendance date cannot be in the future");
        }
    }

    public void markAsCollected() {
        if (status != AttendanceSessionStatus.PENDING && status != AttendanceSessionStatus.REJECTED) {
            throw new IllegalStateException("Session must be in PENDING or REJECTED status to be marked as collected");
        }
        if (delegatedTo == null) {
            throw new IllegalStateException("Session must be delegated to a class leader before collection");
        }
        this.status = AttendanceSessionStatus.COLLECTED;
        this.collectedAt = Instant.now();
        this.updatedAt = Instant.now();
    }

    public void approve(UUID teacherId) {
        if (status != AttendanceSessionStatus.COLLECTED) {
            throw new IllegalStateException("Session must be in COLLECTED status to be approved");
        }
        this.status = AttendanceSessionStatus.APPROVED;
        this.approvedBy = teacherId;
        this.approvedAt = Instant.now();
        this.updatedAt = Instant.now();
        this.rejectionReason = null;
        this.rejectedBy = null;
        this.rejectedAt = null;
    }

    public void reject(UUID teacherId, String reason) {
        if (status != AttendanceSessionStatus.COLLECTED) {
            throw new IllegalStateException("Session must be in COLLECTED status to be rejected");
        }
        if (reason == null || reason.isBlank()) {
            throw new IllegalArgumentException("Rejection reason is required");
        }
        this.status = AttendanceSessionStatus.REJECTED;
        this.rejectedBy = teacherId;
        this.rejectionReason = reason;
        this.rejectedAt = Instant.now();
        this.updatedAt = Instant.now();
        // Reset collected timestamp to allow re-collection
        this.collectedAt = null;
    }

    public void resubmit() {
        if (status != AttendanceSessionStatus.REJECTED) {
            throw new IllegalStateException("Session must be in REJECTED status to be resubmitted");
        }
        this.status = AttendanceSessionStatus.COLLECTED;
        this.collectedAt = Instant.now();
        this.updatedAt = Instant.now();
        this.rejectionReason = null;
        this.rejectedBy = null;
        this.rejectedAt = null;
        // Keep delegatedTo unchanged
    }

    public void delegateTo(UUID classLeaderId) {
        if (status != AttendanceSessionStatus.PENDING) {
            throw new IllegalStateException("Session must be in PENDING status to be delegated");
        }
        if (delegatedTo != null) {
            throw new IllegalStateException("Session is already delegated to " + delegatedTo);
        }
        this.delegatedTo = classLeaderId;
        this.updatedAt = Instant.now();
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public UUID getClassId() {
        return classId;
    }

    public LocalDate getDate() {
        return date;
    }

    public AttendanceSessionStatus getStatus() {
        return status;
    }

    public void setStatus(AttendanceSessionStatus status) {
        this.status = status;
    }

    public UUID getDelegatedTo() {
        return delegatedTo;
    }

    public void setDelegatedTo(UUID delegatedTo) {
        this.delegatedTo = delegatedTo;
    }

    public UUID getCreatedBy() {
        return createdBy;
    }

    public UUID getApprovedBy() {
        return approvedBy;
    }

    public void setApprovedBy(UUID approvedBy) {
        this.approvedBy = approvedBy;
    }

    public UUID getRejectedBy() {
        return rejectedBy;
    }

    public void setRejectedBy(UUID rejectedBy) {
        this.rejectedBy = rejectedBy;
    }

    public String getRejectionReason() {
        return rejectionReason;
    }

    public void setRejectionReason(String rejectionReason) {
        this.rejectionReason = rejectionReason;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public Instant getCollectedAt() {
        return collectedAt;
    }

    public void setCollectedAt(Instant collectedAt) {
        this.collectedAt = collectedAt;
    }

    public Instant getApprovedAt() {
        return approvedAt;
    }

    public void setApprovedAt(Instant approvedAt) {
        this.approvedAt = approvedAt;
    }

    public Instant getRejectedAt() {
        return rejectedAt;
    }

    public void setRejectedAt(Instant rejectedAt) {
        this.rejectedAt = rejectedAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }
}
